// Generated by dts-bundle v0.7.3

declare module 'memd' {
    import { deco_memoize } from 'memd/deco/memoize';
    import { deco_debounce } from 'memd/deco/debounce';
    import { deco_throttle } from 'memd/deco/throttle';
    import { deco_queued } from 'memd/deco/queued';
    import { fn_clearMemoized, fn_memoize } from 'memd/fn/memoize';
    import { Cache } from 'memd/Cache';
    import { FsTransport } from 'memd/persistance/FsTransport';
    import { LocalStorageTransport } from 'memd/persistance/LocalStorageTransport';
    import { CachedWorker } from 'memd/workers/CachedWorker';
    import { fn_queued } from 'memd/fn/queued';
    class Memd {
        static Cache: typeof Cache;
        static fn: {
            memoize: typeof fn_memoize;
            queued: typeof fn_queued;
            clearMemoized: typeof fn_clearMemoized;
        };
        static deco: {
            memoize: typeof deco_memoize;
            throttle: typeof deco_throttle;
            debounce: typeof deco_debounce;
            queued: typeof deco_queued;
        };
        static FsTransport: typeof FsTransport;
        static LocalStorageTransport: typeof LocalStorageTransport;
        static CachedWorker: typeof CachedWorker;
        static default: typeof Memd;
    }
    export = Memd;
}

declare module 'memd/deco/memoize' {
    import { ICacheOpts } from 'memd/Cache';
    import { IMemoizeOpts } from 'memd/fn/memoize';
    export function deco_memoize<TMethod extends (...args: any[]) => any, TThis = any>(opts?: ICacheOpts & IMemoizeOpts<TMethod, TThis>): (target: any, propertyKey: any, descriptor?: any) => any;
}

declare module 'memd/deco/debounce' {
    /**
      *
      * @param timeoutMs ms to wait before calling inner fn
      */
    export function deco_debounce(timeoutMs?: number): (target: any, propertyKey: any, descriptor?: any) => any;
}

declare module 'memd/deco/throttle' {
    interface IThrottleOptions {
            /** Regarding the 1 fn call. The fn will be called at the end of the throttle frame */
            shouldCallLater?: boolean;
            /** Use arguments as throttled key */
            perArguments?: boolean;
    }
    /**
        * Calls function maximal each time window frame
        * @param timeWindow how often, in ms, should the function be called
        * @param shouldCallLater start calling fn on frame start
        */
    export function deco_throttle(timeWindow: number, shouldCallLater?: boolean): any;
    export function deco_throttle(timeWindow: number, options?: IThrottleOptions): any;
    export {};
}

declare module 'memd/deco/queued' {
    export function deco_queued(opts?: {
        trimQueue?: boolean;
        timeout?: number;
        throttle?: number;
    }): (target: any, propertyKey: any, descriptor?: any) => any;
}

declare module 'memd/fn/memoize' {
    import { IMemoizeWrapper } from 'memd/model/IMemoizeWrapper';
    import { ICacheOpts } from 'memd/Cache';
    export interface IMemoizeOpts<TMethod extends (...args: any[]) => any = any, TThis = any> {
        /** Default: false - we cache result for the prototyped method, means the cache is for all instances. Set this to "true", to make the cache for each entity */
        perInstance?: boolean;
        /** Default: false - cache is active only during the promise is in progress */
        clearOnReady?: boolean;
        /** Default: false - remove cached result if promise is rejected */
        clearOnReject?: boolean;
        /** Method to check if cached result, should be removed from cache */
        clearOn?: (val: any) => boolean;
        thisArg?: TThis;
        /** Override key resolver*/
        key?: (options: {
            this?: TThis;
        }, ...args: Parameters<TMethod>) => string;
    }
    export function fn_memoize<TMethod extends (...args: any[]) => any, TThis = any>(fn: TMethod, opts?: ICacheOpts & IMemoizeOpts<TMethod, TThis>, key?: string): IMemoizeWrapper & TMethod;
    export function fn_clearMemoized(fn: Function, ...args: any[]): void;
}

declare module 'memd/Cache' {
    import { ITransport } from 'memd/persistance/ITransport';
    import { IStore } from "memd/persistance/IStore";
    export interface ICacheOpts {
        /** In Seconds */
        maxAge?: number;
        monitors?: ICacheChangeEventMonitor[];
        keyResolver?: (...args: any[]) => string;
        persistance?: ITransport;
        store?: IStore;
        doNotWaitSave?: boolean;
        trackRef?: boolean;
    }
    export interface ICacheChangeEventMonitor {
        on(event: 'change', fn: Function): any;
        off(event: 'change', fn: Function): any;
    }
    export interface ICacheEntry<T = any> {
        timestamp?: number;
        value: T;
    }
    export interface ICacheEntryCollection<T = any> {
        [key: string]: ICacheEntry<T>;
    }
    export class Cache<T = any> {
        options: ICacheOpts;
        static caches: Cache[];
        isAsync: boolean;
        constructor(options?: ICacheOpts);
        resolveKey(...args: any[]): string;
        get(key: string, ...args: any[]): T;
        getAsync(key: string, ...args: any[]): Promise<T>;
        set(key: string, val: T): T;
        setAsync(key: string, val: T): Promise<T>;
        setRestored(coll: ICacheEntryCollection): void;
        clear(key?: string): void;
        clearAsync(key?: string): Promise<void>;
        destroy(): void;
        flushAsync(force?: boolean): Promise<void>;
        static flushAllAsync(): Promise<void>;
        static resolve<T>(cache: Cache<T>, resolver: () => Promise<T>, key?: string): Promise<T>;
    }
}

declare module 'memd/persistance/FsTransport' {
    import { ITransport } from 'memd/persistance/ITransport';
    import { ICacheEntryCollection } from 'memd/Cache';
    export interface IFsTransportOpts {
        path: string;
        browser?: {
            localStorage?: boolean;
        };
    }
    export class FsTransport implements ITransport {
        opts: IFsTransportOpts;
        isAsync: boolean;
        constructor(opts: IFsTransportOpts);
        restoreAsync(): Promise<any>;
        flushAsync(coll: ICacheEntryCollection): Promise<void>;
    }
}

declare module 'memd/persistance/LocalStorageTransport' {
    import { ITransport } from 'memd/persistance/ITransport';
    import { ICacheEntryCollection } from 'memd/Cache';
    export interface ILocalStorageTransport {
        key: string;
    }
    export class LocalStorageTransport implements ITransport {
        opts: ILocalStorageTransport;
        isAsync: boolean;
        constructor(opts: ILocalStorageTransport);
        restore(): any;
        flush(coll: ICacheEntryCollection): void;
    }
}

declare module 'memd/workers/CachedWorker' {
    import { IFsTransportOpts } from 'memd/persistance/FsTransport';
    import { ILocalStorageTransport } from 'memd/persistance/LocalStorageTransport';
    import { ICacheOpts } from 'memd/Cache';
    export interface ICachedWorkerOptions<T> {
        transport: IFsTransportOpts | ILocalStorageTransport;
        worker: () => (T | Promise<T>);
    }
    export class CachedWorker<T> {
        constructor(opts: ICachedWorkerOptions<T> & ICacheOpts);
        run<T>(): T;
        runAsync<T>(): Promise<T>;
        static run<T>(opts: ICachedWorkerOptions<T> & ICacheOpts): T;
        static runAsync<T>(opts: ICachedWorkerOptions<T> & ICacheOpts): Promise<T>;
    }
}

declare module 'memd/fn/queued' {
    interface IQueueOpts {
        /** When the fn is active all further calls will receive active promise */
        single?: boolean;
        /** When the fn is called and the queue has already waiters - remove them */
        trimQueue?: boolean;
        timeout?: number;
        /** the fn call frequence */
        throttle?: number;
    }
    /** For original async method - ensure it is called one after another  */
    export function fn_queued<T extends Function>(fn: T, opts?: IQueueOpts): T;
    export {};
}

declare module 'memd/model/IMemoizeWrapper' {
    export interface IMemoizeWrapper {
        clearArgs(...args: any[]): any;
        clearAll(): any;
    }
}

declare module 'memd/persistance/ITransport' {
    import { ICacheEntryCollection } from 'memd/Cache';
    export interface ITransport<T = any> {
        isAsync: boolean;
        debounceMs?: number;
        restore?(): ICacheEntryCollection<T>;
        restoreAsync?(): Promise<ICacheEntryCollection<T>>;
        flush?(data: ICacheEntryCollection<T>): any;
        flushAsync?(data: ICacheEntryCollection<T>): any;
    }
}

declare module 'memd/persistance/IStore' {
    import { ICacheEntry } from 'memd/Cache';
    export interface IStore<T = any> {
        get?(key: string, ...args: any[]): ICacheEntry<T>;
        getAsync?(key: string, ...args: any[]): Promise<ICacheEntry<T>>;
        save?(key: string, entry: ICacheEntry<T>): void;
        saveAsync?(key: string, entry: ICacheEntry<T>): Promise<void>;
        clear?(key: string): void;
        clearAsync?(key: string): Promise<void>;
    }
}

